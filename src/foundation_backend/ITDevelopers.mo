// import Nat "mo:base/Nat";
// import Text "mo:base/Text";
// import Array "mo:base/Array";
// import Time "mo:base/Time";
// import Int "mo:base/Int";
// import Float "mo:base/Float";

// // Actor for managing IT Developer functionalities
// actor ITDeveloper {

//     // Represents an IT Developer in the system
//     type Developer = {
//         id : Nat;
//         name : Text;
//         email : Text;
//         role : Text; // e.g., "Backend Developer", "Frontend Developer"
//         since : Int; // Timestamp of when they joined
//         assignedTasks : [Task]; // Tasks assigned to the developer
//     };

//     // Represents a task assigned to a developer
//     type Task = {
//         taskId : Nat;
//         title : Text;
//         description : Text;
//         status : Text; // e.g., "Pending", "In Progress", "Completed"
//         priority : Text; // e.g., "Low", "Medium", "High"
//         assignedDate : Int; // Date when the task was assigned
//         dueDate : Int; // Due date for task completion
//     };

//     // Represents settings specific to IT operations
//     type ITSettings = {
//         settingName : Text;
//         value : Text;
//         lastUpdated : Int;
//     };

//     // Represents reports generated by IT Developers
//     type ITReport = {
//         reportId : Nat;
//         developerId : Nat;
//         reportDate : Int;
//         reportType : Text; // e.g., "Bug Fix", "Feature Development"
//         summary : Text; // Summary of the report
//         details : Text; // Detailed report description
//     };

//     // Variables storing IT developer-specific data
//     var developers : [Developer] = [];
//     var tasks : [Task] = [];
//     var settings : [ITSettings] = [];
//     var reports : [ITReport] = [];

//     // Add a new developer
//     public func addDeveloper(newDeveloper : Developer) : async Bool {
//         if (Array.find<Developer>(developers, func(dev) { dev.id == newDeveloper.id }) != null) {
//             return false; // Developer already exists
//         };
//         developers := Array.append<Developer>(developers, [newDeveloper]);
//         return true;
//     };

//     // List all developers
//     public query func listDevelopers() : async [Developer] {
//         return developers;
//     };

//     // Add a new task to the system and assign it to a developer
//     public func addTask(newTask : Task, developerId : Nat) : async Bool {
//         let developerIndex = Array.indexOf<Developer>(
//             {
//                 id = developerId;
//                 name = "";
//                 email = "";
//                 role = "";
//                 since = 0;
//                 assignedTasks = [];
//             },
//             developers,
//             func(dev1 : Developer, dev2 : Developer) : Bool {
//                 dev1.id == dev2.id;
//             },
//         );

//         switch (developerIndex) {
//             case (?idx) {
//                 // Make a mutable copy of the developer
//                 let mutableDevelopers : [var Developer] = Array.thaw(developers);
//                 // mutableDevelopers[idx].assignedTasks := Array.append<Task>(mutableDevelopers[idx].assignedTasks, [newTask]);
//                 developers := Array.freeze<Developer>(mutableDevelopers);
//                 tasks := Array.append<Task>(tasks, [newTask]);
//                 return true;
//             };
//             case null {
//                 return false; // Developer not found
//             };
//         };
//     };

//     // List all tasks in the system
//     public query func listTasks() : async [Task] {
//         return tasks;
//     };

//     // Update task status
//     public func updateTaskStatus(taskId : Nat, newStatus : Text) : async Bool {
//         let taskIndex = Array.indexOf<Task>(
//             {
//                 taskId = taskId;
//                 title = "";
//                 description = "";
//                 status = "";
//                 priority = "";
//                 assignedDate = 0;
//                 dueDate = 0;
//             },
//             tasks,
//             func(task1 : Task, task2 : Task) : Bool {
//                 task1.taskId == task2.taskId;
//             },
//         );

//         switch (taskIndex) {
//             case (?idx) {
//                 // Make a mutable copy of the tasks
//                 let mutableTasks : [var Task] = Array.thaw(tasks);
//                 // mutableTasks[idx].status := newStatus;
//                 tasks := Array.freeze<Task>(mutableTasks);
//                 return true;
//             };
//             case null {
//                 return false; // Task not found
//             };
//         };
//     };

//     // Add a new IT settings
//     public func addITSetting(newSetting : ITSettings) : async () {
//         settings := Array.append<ITSettings>(settings, [newSetting]);
//     };

//     // Update an existing IT setting
//     public func updateITSetting(settingName : Text, newValue : Text) : async Bool {
//         let index = Array.indexOf<ITSettings>(
//             { settingName; value = newValue; lastUpdated = Time.now() },
//             settings,
//             func(setting1 : ITSettings, setting2 : ITSettings) : Bool {
//                 setting1.settingName == setting2.settingName;
//             },
//         );

//         switch (index) {
//             case (?idx) {
//                 let mutableSettings : [var ITSettings] = Array.thaw(settings);
//                 // mutableSettings[idx].value := newValue;
//                 // mutableSettings[idx].lastUpdated := Time.now();
//                 settings := Array.freeze<ITSettings>(mutableSettings);
//                 return true;
//             };
//             case null {
//                 // Add the setting if it does not exist
//                 settings := Array.append<ITSettings>(settings, [{ settingName; value = newValue; lastUpdated = Time.now() }]);
//                 return true;
//             };
//         };
//     };

//     // List all IT settings
//     public query func listITSettings() : async [ITSettings] {
//         return settings;
//     };

//     // Add a new IT report
//     public func addITReport(newReport : ITReport) : async () {
//         reports := Array.append<ITReport>(reports, [newReport]);
//     };

//     // List all IT reports
//     public query func listITReports() : async [ITReport] {
//         return reports;
//     };

//     // Get reports by developer
//     public query func getReportsByDeveloper(developerId : Nat) : async [ITReport] {
//         return Array.filter<ITReport>(reports, func(report) { report.developerId == developerId });
//     };

//     // Function to compute task progress report
//     // Function to compute task progress report
//     public query func computeTaskProgressReport() : async [(Text, Float)] {
//         let totalTasks = Float.fromInt(Array.size(tasks));
//         if (totalTasks == 0.0) {
//             return [("Pending", 0.0), ("In Progress", 0.0), ("Completed", 0.0)];
//         };
//         let pendingTasks = Float.fromInt(Array.size(Array.filter<Task>(tasks, func(task) { task.status == "Pending" })));
//         let inProgressTasks = Float.fromInt(Array.size(Array.filter<Task>(tasks, func(task) { task.status == "In Progress" })));
//         let completedTasks = Float.fromInt(Array.size(Array.filter<Task>(tasks, func(task) { task.status == "Completed" })));

//         return [
//             ("Pending", (pendingTasks / totalTasks) * 100.0),
//             ("In Progress", (inProgressTasks / totalTasks) * 100.0),
//             ("Completed", (completedTasks / totalTasks) * 100.0),
//         ];
//     };

// };

// import Nat "mo:base/Nat";
// import Text "mo:base/Text";
// import Array "mo:base/Array";
// import Time "mo:base/Time";
// import Int "mo:base/Int";
// import Float "mo:base/Float";

// // Actor for managing IT Developer functionalities
// actor ITDeveloper {

//     // Represents an IT Developer in the system
//     type Developer = {
//         id : Nat;
//         name : Text;
//         email : Text;
//         role : Text; // e.g., "Backend Developer", "Frontend Developer"
//         since : Int; // Timestamp of when they joined
//         assignedTasks : [Task]; // Tasks assigned to the developer
//     };

//     // Represents a task assigned to a developer
//     type Task = {
//         taskId : Nat;
//         title : Text;
//         description : Text;
//         status : Text; // e.g., "Pending", "In Progress", "Completed"
//         priority : Text; // e.g., "Low", "Medium", "High"
//         assignedDate : Int; // Date when the task was assigned
//         dueDate : Int; // Due date for task completion
//     };

//     // Represents settings specific to IT operations
//     type ITSettings = {
//         settingName : Text;
//         value : Text;
//         lastUpdated : Int;
//     };

//     // Represents reports generated by IT Developers
//     type ITReport = {
//         reportId : Nat;
//         developerId : Nat;
//         reportDate : Int;
//         reportType : Text; // e.g., "Bug Fix", "Feature Development"
//         summary : Text; // Summary of the report
//         details : Text; // Detailed report description
//     };

//     // Represents cycle token monitoring for IT operations
//     type CycleToken = {
//         id : Nat;
//         tokenAmount : Nat;
//         date : Int;
//         description : Text; // e.g., "Monthly token usage"
//     };

//     // Represents functional and operational business units
//     type OperationalUnit = {
//         unitName : Text;
//         groupId : Nat;
//         initialAmount : Nat;
//         actualAmount : Nat;
//         estimatedValue : Text;
//     };

//     // Variables storing IT developer-specific data
//     var developers : [Developer] = [];
//     var tasks : [Task] = [];
//     var settings : [ITSettings] = [];
//     var reports : [ITReport] = [];
//     var cycleTokens : [CycleToken] = [];
//     var operationalUnits : [OperationalUnit] = [];

//     // Add a new developer
//     public func addDeveloper(newDeveloper : Developer) : async Bool {
//         if (Array.find<Developer>(developers, func(dev) { dev.id == newDeveloper.id }) != null) {
//             return false; // Developer already exists
//         };
//         developers := Array.append<Developer>(developers, [newDeveloper]);
//         return true;
//     };

//     // List all developers
//     public query func listDevelopers() : async [Developer] {
//         return developers;
//     };

//     // Add a new task to the system and assign it to a developer
//     public func addTask(newTask : Task, developerId : Nat) : async Bool {
//         let developerIndex = Array.indexOf<Developer>(
//             {
//                 id = developerId;
//                 name = "";
//                 email = "";
//                 role = "";
//                 since = 0;
//                 assignedTasks = [];
//             },
//             developers,
//             func(dev1 : Developer, dev2 : Developer) : Bool {
//                 dev1.id == dev2.id;
//             },
//         );

//         switch (developerIndex) {
//             case (?idx) {
//                 let mutableDevelopers : [var Developer] = Array.thaw(developers);
//                 // mutableDevelopers[idx].assignedTasks := Array.append<Task>(mutableDevelopers[idx].assignedTasks, [newTask]);
//                 developers := Array.freeze<Developer>(mutableDevelopers);
//                 tasks := Array.append<Task>(tasks, [newTask]);
//                 return true;
//             };
//             case null {
//                 return false; // Developer not found
//             };
//         };
//     };

//     // List all tasks in the system
//     public query func listTasks() : async [Task] {
//         return tasks;
//     };

//     // Update task status
//     public func updateTaskStatus(taskId : Nat, newStatus : Text) : async Bool {
//         let taskIndex = Array.indexOf<Task>(
//             {
//                 taskId = taskId;
//                 title = "";
//                 description = "";
//                 status = "";
//                 priority = "";
//                 assignedDate = 0;
//                 dueDate = 0;
//             },
//             tasks,
//             func(task1 : Task, task2 : Task) : Bool {
//                 task1.taskId == task2.taskId;
//             },
//         );

//         switch (taskIndex) {
//             case (?idx) {
//                 let mutableTasks : [var Task] = Array.thaw(tasks);
//                 // mutableTasks[idx].status := newStatus;
//                 tasks := Array.freeze<Task>(mutableTasks);
//                 return true;
//             };
//             case null {
//                 return false; // Task not found
//             };
//         };
//     };

//     // Add a new IT settings
//     public func addITSetting(newSetting : ITSettings) : async () {
//         settings := Array.append<ITSettings>(settings, [newSetting]);
//     };

//     // Update an existing IT setting
//     public func updateITSetting(settingName : Text, newValue : Text) : async Bool {
//         let index = Array.indexOf<ITSettings>(
//             { settingName; value = newValue; lastUpdated = Time.now() },
//             settings,
//             func(setting1 : ITSettings, setting2 : ITSettings) : Bool {
//                 setting1.settingName == setting2.settingName;
//             },
//         );

//         switch (index) {
//             case (?idx) {
//                 let mutableSettings : [var ITSettings] = Array.thaw(settings);
//                 // mutableSettings[idx].value := newValue;
//                 // mutableSettings[idx].lastUpdated := Time.now();
//                 settings := Array.freeze<ITSettings>(mutableSettings);
//                 return true;
//             };
//             case null {
//                 // Add the setting if it does not exist
//                 settings := Array.append<ITSettings>(settings, [{ settingName; value = newValue; lastUpdated = Time.now() }]);
//                 return true;
//             };
//         };
//     };

//     // List all IT settings
//     public query func listITSettings() : async [ITSettings] {
//         return settings;
//     };

//     // Add a new IT report
//     public func addITReport(newReport : ITReport) : async () {
//         reports := Array.append<ITReport>(reports, [newReport]);
//     };

//     // List all IT reports
//     public query func listITReports() : async [ITReport] {
//         return reports;
//     };

//     // Get reports by developer
//     public query func getReportsByDeveloper(developerId : Nat) : async [ITReport] {
//         return Array.filter<ITReport>(reports, func(report) { report.developerId == developerId });
//     };

//     // Add a new cycle token entry
//     public func addCycleToken(newToken : CycleToken) : async () {
//         cycleTokens := Array.append<CycleToken>(cycleTokens, [newToken]);
//     };

//     // List all cycle tokens
//     public query func listCycleTokens() : async [CycleToken] {
//         return cycleTokens;
//     };

//     // Add a new operational unit
//     public func addOperationalUnit(newUnit : OperationalUnit) : async () {
//         operationalUnits := Array.append<OperationalUnit>(operationalUnits, [newUnit]);
//     };

//     // List all operational units
//     public query func listOperationalUnits() : async [OperationalUnit] {
//         return operationalUnits;
//     };

//     // Function to compute task progress report
//     public query func computeTaskProgressReport() : async [(Text, Float)] {
//         let totalTasks = Float.fromInt(Array.size(tasks));
//         if (totalTasks == 0.0) {
//             return [("Pending", 0.0), ("In Progress", 0.0), ("Completed", 0.0)];
//         };
//         let pendingTasks = Float.fromInt(Array.size(Array.filter<Task>(tasks, func(task) { task.status == "Pending" })));
//         let inProgressTasks = Float.fromInt(Array.size(Array.filter<Task>(tasks, func(task) { task.status == "In Progress" })));
//         let completedTasks = Float.fromInt(Array.size(Array.filter<Task>(tasks, func(task) { task.status == "Completed" })));

//         return [
//             ("Pending", (pendingTasks / totalTasks) * 100.0),
//             ("In Progress", (inProgressTasks / totalTasks) * 100.0),
//             ("Completed", (completedTasks / totalTasks) * 100.0),
//         ];
//     };

// };

import Nat "mo:base/Nat";
import Text "mo:base/Text";
import Array "mo:base/Array";
import Time "mo:base/Time";
import Int "mo:base/Int";
import Float "mo:base/Float";

// Actor for managing IT Developer functionalities
actor ITDeveloper {

    // Represents an IT Developer in the system
    type Developer = {
        id : Nat;
        name : Text;
        email : Text;
        role : Text; // e.g., "Backend Developer", "Frontend Developer"
        since : Int; // Timestamp of when they joined
        assignedTasks : [Task]; // Tasks assigned to the developer
    };

    // Represents a task assigned to a developer
    type Task = {
        taskId : Nat;
        title : Text;
        description : Text;
        status : Text; // e.g., "Pending", "In Progress", "Completed"
        priority : Text; // e.g., "Low", "Medium", "High"
        assignedDate : Int; // Date when the task was assigned
        dueDate : Int; // Due date for task completion
    };

    // Represents settings specific to IT operations
    type ITSettings = {
        settingName : Text;
        value : Text;
        lastUpdated : Int;
    };

    // Represents reports generated by IT Developers
    type ITReport = {
        reportId : Nat;
        developerId : Nat;
        reportDate : Int;
        reportType : Text; // e.g., "Bug Fix", "Feature Development"
        summary : Text; // Summary of the report
        details : Text; // Detailed report description
    };

    // Represents cycle token monitoring for IT operations
    type CycleToken = {
        id : Nat;
        tokenAmount : Nat;
        date : Int;
        description : Text; // e.g., "Monthly token usage"
    };

    // Represents functional and operational business units
    type OperationalUnit = {
        unitName : Text;
        groupId : Nat;
        initialAmount : Nat;
        actualAmount : Nat;
        estimatedValue : Text;
    };

    // Variables storing IT developer-specific data
    var developers : [Developer] = [];
    var tasks : [Task] = [];
    var settings : [ITSettings] = [];
    var reports : [ITReport] = [];
    var cycleTokens : [CycleToken] = [];
    var operationalUnits : [OperationalUnit] = [];

    // Add a new developer
    public func addDeveloper(newDeveloper : Developer) : async Bool {
        if (Array.find<Developer>(developers, func(dev) { dev.id == newDeveloper.id }) != null) {
            return false; // Developer already exists
        };
        developers := Array.append<Developer>(developers, [newDeveloper]);
        return true;
    };

    // List all developers
    public query func listDevelopers() : async [Developer] {
        return developers;
    };

    // Add a new task to the system and assign it to a developer
    public func addTask(newTask : Task, developerId : Nat) : async Bool {
        let developerIndex = Array.indexOf<Developer>(
            {
                id = developerId;
                name = "";
                email = "";
                role = "";
                since = 0;
                assignedTasks = [];
            },
            developers,
            func(dev1 : Developer, dev2 : Developer) : Bool {
                dev1.id == dev2.id;
            },
        );

        switch (developerIndex) {
            case (?idx) {
                let mutableDevelopers : [var Developer] = Array.thaw(developers);
                // mutableDevelopers[idx].assignedTasks := Array.append<Task>(mutableDevelopers[idx].assignedTasks, [newTask]);
                developers := Array.freeze<Developer>(mutableDevelopers);
                tasks := Array.append<Task>(tasks, [newTask]);
                return true;
            };
            case null {
                return false; // Developer not found
            };
        };
    };

    // List all tasks in the system
    public query func listTasks() : async [Task] {
        return tasks;
    };

    // Update task status
    public func updateTaskStatus(taskId : Nat, newStatus : Text) : async Bool {
        let taskIndex = Array.indexOf<Task>(
            {
                taskId = taskId;
                title = "";
                description = "";
                status = "";
                priority = "";
                assignedDate = 0;
                dueDate = 0;
            },
            tasks,
            func(task1 : Task, task2 : Task) : Bool {
                task1.taskId == task2.taskId;
            },
        );

        switch (taskIndex) {
            case (?idx) {
                let mutableTasks : [var Task] = Array.thaw(tasks);
                // mutableTasks[idx].status := newStatus;
                tasks := Array.freeze<Task>(mutableTasks);
                return true;
            };
            case null {
                return false; // Task not found
            };
        };
    };

    // Add a new IT settings
    public func addITSetting(newSetting : ITSettings) : async () {
        settings := Array.append<ITSettings>(settings, [newSetting]);
    };

    // Update an existing IT setting
    public func updateITSetting(settingName : Text, newValue : Text) : async Bool {
        let index = Array.indexOf<ITSettings>(
            { settingName; value = newValue; lastUpdated = Time.now() },
            settings,
            func(setting1 : ITSettings, setting2 : ITSettings) : Bool {
                setting1.settingName == setting2.settingName;
            },
        );

        switch (index) {
            case (?idx) {
                let mutableSettings : [var ITSettings] = Array.thaw(settings);
                // mutableSettings[idx].value := newValue;
                // mutableSettings[idx].lastUpdated := Time.now();
                settings := Array.freeze<ITSettings>(mutableSettings);
                return true;
            };
            case null {
                // Add the setting if it does not exist
                settings := Array.append<ITSettings>(settings, [{ settingName; value = newValue; lastUpdated = Time.now() }]);
                return true;
            };
        };
    };

    // List all IT settings
    public query func listITSettings() : async [ITSettings] {
        return settings;
    };

    // Add a new IT report
    public func addITReport(newReport : ITReport) : async () {
        reports := Array.append<ITReport>(reports, [newReport]);
    };

    // List all IT reports
    public query func listITReports() : async [ITReport] {
        return reports;
    };

    // Get reports by developer
    public query func getReportsByDeveloper(developerId : Nat) : async [ITReport] {
        return Array.filter<ITReport>(reports, func(report) { report.developerId == developerId });
    };

    // Add a new cycle token entry
    public func addCycleToken(newToken : CycleToken) : async () {
        cycleTokens := Array.append<CycleToken>(cycleTokens, [newToken]);
    };

    // List all cycle tokens
    public query func listCycleTokens() : async [CycleToken] {
        return cycleTokens;
    };

    // Add a new operational unit
    public func addOperationalUnit(newUnit : OperationalUnit) : async () {
        operationalUnits := Array.append<OperationalUnit>(operationalUnits, [newUnit]);
    };

    // List all operational units
    public query func listOperationalUnits() : async [OperationalUnit] {
        return operationalUnits;
    };

    // Function to compute task progress report
    public query func computeTaskProgressReport() : async [(Text, Float)] {
        let totalTasks = Float.fromInt(Array.size(tasks));
        if (totalTasks == 0.0) {
            return [("Pending", 0.0), ("In Progress", 0.0), ("Completed", 0.0)];
        };
        let pendingTasks = Float.fromInt(Array.size(Array.filter<Task>(tasks, func(task) { task.status == "Pending" })));
        let inProgressTasks = Float.fromInt(Array.size(Array.filter<Task>(tasks, func(task) { task.status == "In Progress" })));
        let completedTasks = Float.fromInt(Array.size(Array.filter<Task>(tasks, func(task) { task.status == "Completed" })));

        return [
            ("Pending", (pendingTasks / totalTasks) * 100.0),
            ("In Progress", (inProgressTasks / totalTasks) * 100.0),
            ("Completed", (completedTasks / totalTasks) * 100.0),
        ];
    };

};
